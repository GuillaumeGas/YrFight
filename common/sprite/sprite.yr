mod common.sprite.sprite;

import std.map;
import std.json;
import std.vec;

import common.lib.sdl;
import common.sprite.spriteitem;
import common.sprite.animation;
import common.resource;
import common.lib.file;
import common.lib.jsonParser;
import common.lib.parser.parser;
import common.drawable;
import common.sprite.spritedrawable;

struct
| spriteFrame : BTreeMap!(string,SpriteItem) 
| animations : BTreeMap!(string,Animation)
| filepath : string
| load : bool
 -> Sprite;

// Sprite
def addSpriteItem(ref sprite : Sprite, item : SpriteItem){
    sprite.spriteFrame.insert(item.name,item);
    for key, value in sprite.spriteFrame {
        println("Box ", key, ": ", value.position.x, ", ", value.position.y, ", ", value.position.w, ", ", value.position.h);
    }
}

def removeSpriteItem(ref sprite : Sprite, id : string){
    sprite.spriteFrame.remove(id);
}

def addAnimation(ref sprite : Sprite, anim : Animation){
    sprite.animations.insert(anim.name,anim);
}

def removeAnimation(ref sprite : Sprite, id : string){
    sprite.animations.remove(id);
}

def loadSpritePackage(path : string, renderer : p!SDL_Renderer) -> Sprite{
    //path to the .sprt (renamed zip) file
    //uncompress
    let jsonPath = "";
    let sprite = tryLoadJson(jsonPath);
    if(renderer !is null)
        sprite.loadResource(renderer);
    return sprite;    
}

// return a sprite. If the file doesn't exist, an empty sprite will be returned with boolean load to false.
def tryLoadJson(path : string) -> Sprite{
    let spriteObj = Sprite::init;
    if(path != ""){
        let json = parseJson(path~".json");
        println(json.toString());
        spriteObj = common::sprite::sprite::fromJson(json);
        spriteObj.filepath = path;//remove json extension here (string replace)
    }
    return spriteObj;
}

def fromJson(json : JsonValue) -> Sprite{
    let sprite = Sprite::init;
    if(json.type == JSON_TYPE::OBJECT){
        let spriteItems = ("spriteItems" in json.obj);
        if(spriteItems !is null && spriteItems.type == JSON_TYPE::ARRAY){
            for elem in spriteItems.array{
                let item = common::sprite::spriteitem::fromJson(elem);
                sprite.spriteFrame.insert(item.name, item);
            }
        }
    }
    return sprite;
}

// init the resource in the manager
def loadResource(ref sprite : Sprite, renderer : p!SDL_Renderer) -> bool{
    getResourcesManager().addResource(sprite.filepath,renderer);
    return getResourcesManager().getResource(sprite.filepath) !is null;
}

def toJson(ref sprite : Sprite) -> JsonValue
{
    let json = JsonValue::init;
    json.type = JSON_TYPE::OBJECT;
    
    let spriteItemJson = JsonValue::init;
    spriteItemJson.type = JSON_TYPE::ARRAY;        
    for key, value in sprite.spriteFrame{
        spriteItemJson.array.push(value.toJson());
    }
    
    json.obj.insert("spriteItems", spriteItemJson);
    return json;
}


def toJsonFile(ref sprite : Sprite, path : string){
    let file = File::init;
    if(file.open( path, "w")){        
        let json = sprite.toJson();
        file.close();
    }       
}

def getDrawable(ref sprite : Sprite, spriteId : string, dst : SDL_Rect) -> Drawable
{
    let item = (spriteId in sprite.spriteFrame);
    if(item !is null){
        return Drawable{ item.position, dst , getResourcesManager().getResource(sprite.filepath) };
    }
    return Drawable::init;
}

def getSpriteDrawable(ref sprite : Sprite, spriteId : string) -> SpriteDrawable{
    let item = (spriteId in sprite.spriteFrame);
    if(item !is null)
        return SpriteDrawable{ *item, sprite.getDrawable(spriteId,SDL_Rect{0,0,0,0})};
    return SpriteDrawable::init;
}

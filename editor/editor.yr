mod editor.editor;

import core.io;
import std.list;
import std.map;
import std.conv;

import common.screen;
import common.lib.signal;
import common.lib.sdl;
import common.resource;
import editor.eventHandler;
import common.drawable;
import common.sprite.sprite;
import common.sprite.spriteitem;

struct
| screen : Screen
| eventHdl : EventHandler
| continue : bool
| selection : SDL_Rect
| mouse : SDL_Point
| currentSelectedPos : bool
| drawable : Drawable
| sprite : Sprite
 -> Editor;

cte gWindowWidth = 640;
cte gWindowHeight = 480;
cte gWindowPosX = 2024;
cte gWindowPosY = 100;
cte gTitle = "YrFight Editor";

def createEditor (ref editor : Editor, width : u32, height : u32) 
{
    editor.screen = createScreen (gTitle, cast!i32 (width), cast!i32 (height), gWindowPosX, gWindowPosY);
    editor.eventHdl = createEventHandler (editor);
    initEvents (editor.eventHdl);
}

def createEditor (ref editor : Editor, filepath : string)
{
    editor.createEditor (cast!u32 (gWindowWidth), cast!u32 (gWindowHeight));
    editor.sprite = tryLoadJson(filepath);
    editor.sprite.loadResource(editor.screen.renderer);
    //we must resize the window to the size of the sprite or the max size of the screen
    editor.drawable = Drawable { SDL_Rect { 0, 0, 0, 0 }, SDL_Rect {0, 0, 0, 0} , getResourcesManager().getResource(filepath) };
    editor.screen.addDrawable(&(editor.drawable));
    editor.continue = true;
}

def start (ref editor : Editor)
{
    on exit => editor.screen.destroy ();
    while (editor.continue)
    {
        editor.screen.clear ();
        editor.eventHdl.handleEvents ();
        editor.screen.draw();
        editor.drawSelection();
        editor.drawMouse();
        editor.screen.display ();
    }
}

def initEvents (ref eventHdl : EventHandler)
{
    let quitSignal = Signal!(ref Editor)::init;
    quitSignal.connect (onQuit);

    let mouseMotionSignal = Signal!(ref Editor, (i32, i32))::init;
    mouseMotionSignal.connect (onMouseMotion);

    let mouseClickSignal = Signal!(ref Editor, (i32, i32))::init;
    mouseClickSignal.connect (onMouseClick);

    let cancelSignal = Signal!(ref Editor)::init;
    cancelSignal.connect (onCancel);
    
    let zoomInSignal = Signal!(ref Editor)::init;
    zoomInSignal.connect (onZoomIn);
    let zoomOutSignal = Signal!(ref Editor)::init;
    zoomOutSignal.connect (onZoomOut);    

    eventHdl.onEvent (SDL_EventType::QUIT, quitSignal);
    eventHdl.onEvent (SDL_EventType::KEYUP, SDL_Keycode::SDLK_ESCAPE, cancelSignal);
    eventHdl.onEvent (SDL_EventType::KEYUP, SDL_Keycode::SDLK_UP, zoomInSignal);
    eventHdl.onEvent (SDL_EventType::KEYUP, SDL_Keycode::SDLK_DOWN, zoomOutSignal);
    eventHdl.onEvent (mouseMotionSignal);
    eventHdl.onEvent (SDL_EventType::MOUSEBUTTONUP, SDL_Mousecode::SDL_BUTTON_LEFT, mouseClickSignal);
}

def onQuit (ref editor : Editor)
{
    editor.continue = false;
    println ("Bye !");
}

def onMouseMotion (ref editor : Editor, pos : (i32, i32))
{
    let (x, y) = pos;
    let newX = cast!i32((cast!i32(x/editor.screen.zoom))*editor.screen.zoom);
    let newY = cast!i32((cast!i32(y/editor.screen.zoom))*editor.screen.zoom);
    if(newX != editor.mouse.x || newY != editor.mouse.y){
        editor.mouse.x = newX;
        editor.mouse.y = newY;
        if(editor.currentSelectedPos)
        {
            editor.selection.w = x-editor.selection.x;
            editor.selection.h = y-editor.selection.y;
        }
    }
}

def onMouseClick (ref editor : Editor, pos : (i32, i32))
{
    let (x, y) = pos;
    // if nothing is selected
    if(!editor.currentSelectedPos){
        editor.selection.x = x;
        editor.selection.y = y;
        editor.selection.w = 0;
        editor.selection.h = 0;
        editor.currentSelectedPos = true;
    }else{// we add a new SpriteItem to the Sprite and we reset the selection
        editor.currentSelectedPos = false;
        let spriteitem = SpriteItem::init;
        spriteitem.position.x = cast!i32(editor.selection.x/editor.screen.zoom);
        spriteitem.position.y = cast!i32(editor.selection.y/editor.screen.zoom);
        spriteitem.position.w = cast!i32((x-editor.selection.x)/editor.screen.zoom);
        spriteitem.position.h = cast!i32((y-editor.selection.y)/editor.screen.zoom);
        spriteitem.name = to!string(editor.sprite.spriteFrame.len);
        editor.sprite.addSpriteItem(spriteitem);
        println("Rect ", spriteitem.position.x, ", ", spriteitem.position.y, ", ", x, ", ", y);
    }
}

def drawSelection(ref editor : Editor){
    SDL_SetRenderDrawColor(editor.screen.renderer, cast!u8(237), cast!u8(28), cast!u8(36) , cast!u8(255));
    for key, value in editor.sprite.spriteFrame {
        let tmpVal = value;
        tmpVal.position.x = cast!i32(value.position.x * editor.screen.zoom);
        tmpVal.position.y = cast!i32(value.position.y * editor.screen.zoom);
        tmpVal.position.w = cast!i32(value.position.w * editor.screen.zoom);
        tmpVal.position.h = cast!i32(value.position.h * editor.screen.zoom);
        editor.drawRect(tmpVal.position);
    }
    if(editor.currentSelectedPos)
        editor.drawRect(editor.selection);   
}

def drawRect(ref editor : Editor, pos : SDL_Rect){
    for i in 0 .. 4
    {
        let tmp = pos;
        if(i == 0){
            tmp.h = cast!i32(editor.screen.zoom);
        }
        else if(i == 1){
            tmp.x = tmp.x + tmp.w - cast!i32(editor.screen.zoom);
            tmp.w = cast!i32(editor.screen.zoom);
        }
        else if(i == 2){
            tmp.y = tmp.y + tmp.h - cast!i32(editor.screen.zoom);
            tmp.h = cast!i32(editor.screen.zoom);
        }
        else if(i == 3){
            tmp.w = cast!i32(editor.screen.zoom);
        }
        SDL_RenderFillRect(editor.screen.renderer, &tmp);
    }
}

def drawMouse(ref editor : Editor){
    let pos = SDL_Rect::init;
    pos.x = editor.mouse.x;
    pos.y = editor.mouse.y;
    pos.w = cast!i32(editor.screen.zoom);
    pos.h = cast!i32(editor.screen.zoom);
    SDL_RenderFillRect(editor.screen.renderer, &(pos)); 
}

def onCancel(ref editor : Editor){
    if(editor.currentSelectedPos)
        editor.currentSelectedPos = false;
}

def onZoomIn(ref editor : Editor){
    editor.screen.zoomIn();
}

def onZoomOut(ref editor : Editor){
    editor.screen.zoomOut();
}
